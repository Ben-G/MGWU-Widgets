////  SWTableView.m//  SWTable////  Copyright (c) 2010 Sangwoo Im//  Copyright 2013 MakeGamesWithUs Inc.//  Modified by Brian Chu for MakeGamesWithUs////  Permission is hereby granted, free of charge, to any person obtaining a copy//  of this software and associated documentation files (the "Software"), to deal//  in the Software without restriction, including without limitation the rights//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//  copies of the Software, and to permit persons to whom the Software is//  furnished to do so, subject to the following conditions:////  The above copyright notice and this permission notice shall be included in//  all copies or substantial portions of the Software.////  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//  THE SOFTWARE.//#import "SWTableView.h"#import "SWTableViewCell.h"#import "CCMenu.h"#import "CGPointExtension.h"#import "SWSorting.h"#import "CCLayer.h"@interface SWScrollView()@property (nonatomic, assign) BOOL    touchMoved_;@property (nonatomic, retain) CCLayer *container_;@property (nonatomic, assign) CGPoint touchPoint_;@end@interface SWTableView ()-(NSInteger)__indexFromOffset:(CGPoint)offset;-(NSUInteger)_indexFromOffset:(CGPoint)offset;-(CGPoint)__offsetFromIndex:(NSInteger)index;-(CGPoint)_offsetFromIndex:(NSUInteger)index;-(void)_updateContentSize;@end@interface SWTableView (Private)- (SWTableViewCell *)_cellWithIndex:(NSUInteger)cellIndex;- (void)_moveCellOutOfSight:(SWTableViewCell *)cell;- (void)_setIndex:(NSUInteger)index forCell:(SWTableViewCell *)cell;- (void)_addCellIfNecessary:(SWTableViewCell *)cell;@end@implementation SWTableView@synthesize delegate   = tDelegate_;@synthesize dataSource = dataSource_;@synthesize verticalFillOrder  = vordering_;+(id)viewWithDataSource:(id<SWTableViewDataSource>)dataSource size:(CGSize)size{    return [self viewWithDataSource:dataSource size:size container:nil];}+(id)viewWithDataSource:(id <SWTableViewDataSource>)dataSource size:(CGSize)size container:(CCNode *)container {    SWTableView *table;    table = [[self alloc] initWithViewSize:size container:container];    table.dataSource = dataSource;    table.hasVariableCellSize = dataSource.hasVariableCellSize;    [table _updateContentSize];        //added fix ****    [table setContentOffset:ccp(0,[table minContainerOffset].y)];;    //end added fix ****        return table;}-(id)initWithViewSize:(CGSize)size container:(CCNode *)container {    if ((self = [super initWithViewSize:size container:container])) {        cellsUsed_      = [NSMutableArray new];        cellsFreed_     = [NSMutableArray new];        indices_        = [NSMutableIndexSet new];        tDelegate_      = nil;        vordering_      = SWTableViewFillBottomUp;        self.direction  = SWScrollViewDirectionVertical;                [super setDelegate:self];    }    return self;}#pragma mark - #pragma mark property-(void)setVerticalFillOrder:(SWTableViewVerticalFillOrder)fillOrder {    if (vordering_ != fillOrder) {        vordering_ = fillOrder;        if ([cellsUsed_ count] > 0) {            [self reloadData];        }    }}#pragma mark -#pragma mark public-(void)reloadData {            @autoreleasepool {        for (SWTableViewCell *cell in cellsUsed_) {            [cellsFreed_ addObject:cell];            [cell reset];            if (cell.parent == self.container_) {                [container_ removeChild:cell cleanup:NO];            }        }        [indices_ removeAllIndexes];                cellsUsed_ = [NSMutableArray new];        _hasVariableCellSize = [dataSource_ hasVariableCellSize];        [self _updateContentSize];        if ([dataSource_ numberOfCellsInTableView:self] > 0) {            [self scrollViewDidScroll:self];        }    }}-(NSArray*) cellsUsed{    return cellsUsed_;}-(SWTableViewCell *)cellAtIndex:(NSUInteger)idx {    return [self _cellWithIndex:idx];}-(void)updateCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        return;    }        SWTableViewCell   *cell;        cell = [self _cellWithIndex:idx]; //this gets the cell from cellsUsed    if (cell) {        [self _moveCellOutOfSight:cell]; //if cell is still in cellsUsed, remove it    }     cell = [dataSource_ tableView:self cellAtIndex:idx];    [self _setIndex:idx forCell:cell];    [self _addCellIfNecessary:cell];}-(void)insertCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        return;    }    SWTableViewCell   *cell;    NSInteger         newIdx;        cell        = [cellsUsed_ objectWithObjectID:idx];    if (cell) {        newIdx = [cellsUsed_ indexOfSortedObject:cell];        for (int i=newIdx; i<[cellsUsed_ count]; i++) {            cell = [cellsUsed_ objectAtIndex:i];            [self _setIndex:cell.idx+1 forCell:cell];        }    }        [indices_ shiftIndexesStartingAtIndex:idx by:1];        //insert a new cell    cell = [dataSource_ tableView:self cellAtIndex:idx];    [self _setIndex:idx forCell:cell];    [self _addCellIfNecessary:cell];        [self _updateContentSize];}-(void)removeCellAtIndex:(NSUInteger)idx {    if (idx == NSNotFound || idx > [dataSource_ numberOfCellsInTableView:self]-1) {        return;    }        SWTableViewCell   *cell;    NSInteger         newIdx;        cell = [self _cellWithIndex:idx];    if (!cell) {        return;    }        newIdx = [cellsUsed_ indexOfSortedObject:cell];        //remove first    [self _moveCellOutOfSight:cell];        [indices_ shiftIndexesStartingAtIndex:idx+1 by:-1];    for (int i=[cellsUsed_ count]-1; i > newIdx; i--) {        cell = [cellsUsed_ objectAtIndex:i];        [self _setIndex:cell.idx-1 forCell:cell];    }}-(SWTableViewCell *)dequeueCell {    SWTableViewCell *cell;        if ([cellsFreed_ count] > 0)    {        if (vordering_ == SWTableViewFillTopDown)        {            cell = [cellsFreed_ lastObject];            [cellsFreed_ removeLastObject];        }        else        {            cell = [cellsFreed_ objectAtIndex:0];            [cellsFreed_ removeObjectAtIndex:0];                    }    }    return cell;}#pragma mark -#pragma mark private- (void)_addCellIfNecessary:(SWTableViewCell *)cell {    if (cell.parent != self.container_) {        [self.container_ addChild:cell];    }    [cellsUsed_ insertSortedObject:cell];    [indices_ addIndex:cell.idx];}//sets container (a child of this class)- (void)_updateContentSize {    CGSize     size, cellSize;    NSUInteger cellCount;        if (!_hasVariableCellSize)    {        cellSize  = [dataSource_ tableView:self cellSizeForIndex:0];        cellCount = [dataSource_ numberOfCellsInTableView:self];                switch (self.direction) {            case SWScrollViewDirectionHorizontal:                //size = dataSource_.tableContentSize;                size = CGSizeMake(cellCount * cellSize.width, cellSize.height);                size.width  = MAX(size.width,  viewSize_.width); //added fix ****                break;            default:                //size = dataSource_.tableContentSize;                size = CGSizeMake(cellSize.width, cellCount * cellSize.height);                size.height = MAX(size.height, viewSize_.height); //added fix ****                break;        }    }    else    {        size = dataSource_.tableContentSize;        switch (self.direction) {            case SWScrollViewDirectionHorizontal:                size.width  = MAX(size.width,  viewSize_.width);                break;            default:                size.height = MAX(size.height, viewSize_.height);                break;        }    }    [self setContentSize:size];}//offset returned is distance from bottom of container to bottom of cell whose index is inputted//in the case of a variable cell size, __offsetFromIndex returns the result without needing to be modified further- (CGPoint)_offsetFromIndex:(NSUInteger)index {    CGPoint offset = [self __offsetFromIndex:index];    if (vordering_ == SWTableViewFillTopDown)    {        if (!_hasVariableCellSize)        {            CGSize cellSize  = [dataSource_ tableView:self cellSizeForIndex:0];            offset.y = container_.contentSize.height - offset.y - cellSize.height;        }        else        {            offset.y = container_.contentSize.height - offset.y - [dataSource_ tableView:self cellSizeForIndex:index].height;        }    }            return offset; }//returns distance from top of first cell to top of cell at that index- (CGPoint)__offsetFromIndex:(NSInteger)index {    CGPoint offset;    CGSize  cellSize;            switch (self.direction) {        case SWScrollViewDirectionHorizontal:            if (!_hasVariableCellSize)            {                cellSize  = [dataSource_ tableView:self cellSizeForIndex:0];                offset = ccp(cellSize.width * index, 0.0f);            }            else //TODO: NEED TO MAKE SURE THIS WORKS FOR NOT SWTABLEVIEWFILL*TOPDOWN* - for not those cases, the first stage offsetfromindex needs to return distance from top of container to top of cell                offset = ccp([dataSource_ tableView:self widthFromCellIndex:0 toIndex:index], 0.0f);            break;        default:            if (!_hasVariableCellSize)            {                cellSize  = [dataSource_ tableView:self cellSizeForIndex:0];                offset = ccp(0.0f, cellSize.height * index);            }            else            {                offset = ccp(0.0f, [dataSource_ tableView:self heightFromCellIndex:0 toIndex:index]);            }            break;    }        return offset;}/* If we have cells 1, 2, and 3, each 44 px in size: cell 3 is returned from [-infinity, 0], cell 2 is returned from (0,44], cell 1 is returned from (44,infinity] On initialization (scrollViewDidScroll calling this method), the offset = bottom position of the upper-most visible cell, relative to bottom of container (not bottom of view) */-(void) testIndexFromOffset{    for (int i = 0; i< 880; i++)    {        [self _indexFromOffset:ccp(0,i)];    }}//offset is distance from top of the last cell to bottom of the cell we want index of//for SWFillTopDown, bottom of the cell is exclusive, top of the cell is inclusive//Meaning: if your cell height is 44, and you have cells 0,1,2,3; cell 3 would be returned for offsets from (-infinity, 0], 2 from (0,44], 1 from (44,88], and 0 from (88, infinity]- (NSUInteger)_indexFromOffset:(CGPoint)offset {    NSInteger index;    const NSInteger maxIdx = [dataSource_ numberOfCellsInTableView:self]-1;            CGSize cellSize;    if (vordering_ == SWTableViewFillTopDown)    {        offset.y = container_.contentSize.height - offset.y;        if (!_hasVariableCellSize)        {            cellSize = [dataSource_ tableView:self cellSizeForIndex:0]; //this accounts for the off-by-one difference between the # of cells and the max cell index            offset.y = offset.y - cellSize.height;            //for fixed cell size, now, offset = distance from "top of the cell we want index of" to the top of the container (not the view!)        }    //for variable cell size, now, offset = distance from "bottom of the cell we want index of" to the top of the container (not the view!)    }    if (!_hasVariableCellSize)        index = MAX(0, [self __indexFromOffset:offset]);    else        index = MAX(0, [self __indexFromOffsetVariableSize:offset]);    index = MIN(index, maxIdx);        return index;}- (NSInteger)__indexFromOffset:(CGPoint)offset {    NSInteger  index;    CGSize     cellSize;        //offset is distance from top of the cell we want index of top of container    cellSize  = [dataSource_ tableView:self cellSizeForIndex:0];        switch (self.direction) {        case SWScrollViewDirectionHorizontal:            index = offset.x/cellSize.width;            break;        default:            index = offset.y/cellSize.height;            break;    }        return index;}- (NSInteger)__indexFromOffsetVariableSize:(CGPoint)offset {    NSInteger  index;        //if v-order if fillTopDown, offset is distance from '[bottom of] cell we want index of' to top of container        NSUInteger numCells = [dataSource_ numberOfCellsInTableView:self];        switch (self.direction) {        case SWScrollViewDirectionHorizontal:            for (NSUInteger i=0; i<numCells ; i++)            {                offset.x = offset.x - [dataSource_ tableView:self cellSizeForIndex:i].width;                if (offset.x < 0)                {                    return i;                }                else if (offset.x==0)                {                    return i+1;                }            }            //else            return numCells-1; //index cannot be greater than this            break;                    default:            //count from top-> down            if (vordering_ == SWTableViewFillTopDown)            {                offset.y = offset.y - [dataSource_ tableView:self cellSizeForIndex:0].height;            }            if (offset.y<=0)            {                return 0; //HACK            }            //NEED TO FIX FOR WHERE FILL IS NOT TOPDOWN  (i=0)            for (NSUInteger i=1; i<numCells; i++)            {                offset.y = offset.y - [dataSource_ tableView:self cellSizeForIndex:i].height;                if (offset.y < 0)                {                    return i; //i                }                else if (offset.y==0)                {                    return i; //i+1                }            }                        //else            return numCells-1; //index cannot be greater than this            break;    }        return index;}- (SWTableViewCell *)_cellWithIndex:(NSUInteger)cellIndex {    SWTableViewCell *found;        found = nil;        if ([indices_ containsIndex:cellIndex]) {        found = (SWTableViewCell *)[cellsUsed_ objectWithObjectID:cellIndex];    }        return found;}//move cell to cellsFreed, remove from container- (void)_moveCellOutOfSight:(SWTableViewCell *)cell {    [cellsFreed_ addObject:cell];    [cellsUsed_ removeSortedObject:cell];    [indices_ removeIndex:cell.idx];    [cell reset];    if (cell.parent == self.container_)    {        [container_ removeChild:cell cleanup:YES];    }}- (void)_setIndex:(NSUInteger)index forCell:(SWTableViewCell *)cell {    cell.anchorPoint = ccp(0.0f, 0.0f);    cell.position    = [self _offsetFromIndex:index];    cell.idx         = index;}#pragma mark -#pragma mark scrollView-(void)refresh{	if ([tDelegate_ respondsToSelector:@selector(refresh)])		[tDelegate_ refresh];}-(void)scrollViewDidScroll:(SWScrollView *)view {    NSUInteger        startIdx, endIdx, idx, maxIdx;    CGPoint           offset;            maxIdx   = [dataSource_ numberOfCellsInTableView:self];        if (maxIdx == 0) {        return; // early termination    }        @autoreleasepool {        offset   = ccpMult([self contentOffset], -1); //including negative factor, distance from bottom of view window to bottom of container (positive direction is pulling cells down)        maxIdx   = MAX(maxIdx - 1, 0);                        if (vordering_ == SWTableViewFillTopDown) {            if (!_hasVariableCellSize)            {                CGSize cellSize  = [dataSource_ tableView:self cellSizeForIndex:0];                offset.y = offset.y + viewSize_.height/container_.scaleY - cellSize.height; //bottom position of the upper most visible cell, relative to bottom of container (not bottom of view)                //the above comment is not entirely accurate, since we have the overshoot problem            }            else if ([cellsUsed_ count]>0) //cells in view            { //***confused, this way of understanding does not seem to work if the top-most cell is pulled down excessively (bounce)                offset.y = offset.y + viewSize_.height/container_.scaleY;                //PROBLEM IS THAT SUBTRACTING CELLSIZE/HEIGHT OF CELL AT FIRST INDEX MAKES THE OFFSET "OVERSHOOT"            }            else            {                offset.y = offset.y + viewSize_.height/container_.scaleY - [dataSource_ tableView:self cellSizeForIndex:0].height; //INVESTIGATE THIS FOR WHEN THERE IS ONLY ONE CELL            }        }                startIdx = [self _indexFromOffset:offset]; //offset is distance from top of the last cell to cell we want index of (for variable cells only)                        if (vordering_ == SWTableViewFillTopDown) {            offset.y -= viewSize_.height/container_.scaleY;        } else {            offset.y += viewSize_.height/container_.scaleY;        }        offset.x += viewSize_.width/container_.scaleX;               endIdx   = [self _indexFromOffset:offset];                        if ([cellsUsed_ count] > 0) {            idx = [[cellsUsed_ objectAtIndex:0] idx];            while(idx <startIdx) {                SWTableViewCell *cell = [cellsUsed_ objectAtIndex:0];                [self _moveCellOutOfSight:cell];                if ([cellsUsed_ count] > 0) {                    idx = [[cellsUsed_ objectAtIndex:0] idx];                     } else {                    break;                }            }        }        if ([cellsUsed_ count] > 0) {            idx = [[cellsUsed_ lastObject] idx];            while(idx <= maxIdx && idx > endIdx) {                SWTableViewCell *cell = [cellsUsed_ lastObject];                [self _moveCellOutOfSight:cell];                if ([cellsUsed_ count] > 0) {                    idx = [[cellsUsed_ lastObject] idx];                   } else {                    break;                }            }        }                for (NSUInteger i=startIdx; i <= endIdx; i++) {            if ([indices_ containsIndex:i]) {                continue;            }            [self updateCellAtIndex:i];        }    }}#pragma mark -#pragma mark Touch events-(void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {    if (!self.visible) {        return;    }//    if ([touches_ count] == 1 && !self.touchMoved_) {//        NSUInteger        index;//        SWTableViewCell   *cell;//        CGPoint           point;//        //        point = [container_ convertTouchToNodeSpace:touch];//        if (vordering_ == SWTableViewFillTopDown) {//            //            CGSize cellSize  = [dataSource_ tableView:self cellSizeForIndex:0];//            point.y -= cellSize.height;//        }//        index = [self _indexFromOffset:point];//        cell  = [self _cellWithIndex:index];//        //        if (cell) {//            [tDelegate_ table:self cellTouched:cell];   //        }//    }    [super ccTouchEnded:touch withEvent:event];}@end